<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | icps]]></title>
  <link href="http://icps0610.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://icps0610.github.io/"/>
  <updated>2018-10-13T06:17:11+08:00</updated>
  <id>http://icps0610.github.io/</id>
  <author>
    <name><![CDATA[icps]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pycall]]></title>
    <link href="http://icps0610.github.io/blog/2018/10/07/pycall/"/>
    <updated>2018-10-07T11:44:45+08:00</updated>
    <id>http://icps0610.github.io/blog/2018/10/07/pycall</id>
    <content type="html"><![CDATA[<pre><code class="ruby">require 'pycall/import'
include PyCall::Import
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting-a-two-dimensional-array]]></title>
    <link href="http://icps0610.github.io/blog/2018/10/05/sort-by/"/>
    <updated>2018-10-05T18:31:04+08:00</updated>
    <id>http://icps0610.github.io/blog/2018/10/05/sort-by</id>
    <content type="html"><![CDATA[<blockquote><p>ref <a href="https://stackoverflow.com/questions/7033719/sorting-a-two-dimensional-array-by-second-value">https://stackoverflow.com/questions/7033719/sorting-a-two-dimensional-array-by-second-value</a></p></blockquote>

<p>arr.sort_by{|x,y|y}
arr.sort_by(&amp;:last)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fuzzystringmatch]]></title>
    <link href="http://icps0610.github.io/blog/2018/10/05/fuzzystringmatch/"/>
    <updated>2018-10-05T14:07:20+08:00</updated>
    <id>http://icps0610.github.io/blog/2018/10/05/fuzzystringmatch</id>
    <content type="html"><![CDATA[<h3><a href="https://github.com/kiyoka/fuzzy-string-match">https://github.com/kiyoka/fuzzy-string-match</a></h3>

<p>require &lsquo;fuzzystringmatch&rsquo;
jarow = FuzzyStringMatch::JaroWinkler.create( :native )
p jarow.getDistance(  &ldquo;jones&rdquo;,      &ldquo;johnson&rdquo; )</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Waitr-scoll]]></title>
    <link href="http://icps0610.github.io/blog/2018/09/24/waitr-scoll/"/>
    <updated>2018-09-24T20:38:17+08:00</updated>
    <id>http://icps0610.github.io/blog/2018/09/24/waitr-scoll</id>
    <content type="html"><![CDATA[<h3><a href="https://github.com/p0deje/watir-scroll">https://github.com/p0deje/watir-scroll</a></h3>

<pre><code class="ruby">browser = Watir::Browser.new :firefox
browser.button(text: 'Click').scroll.by(0, 800)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove_black]]></title>
    <link href="http://icps0610.github.io/blog/2018/09/23/remove-black/"/>
    <updated>2018-09-23T16:39:45+08:00</updated>
    <id>http://icps0610.github.io/blog/2018/09/23/remove-black</id>
    <content type="html"><![CDATA[<pre><code class="ruby"># encoding: utf-8
require "watir"
require 'rmagick'

def pixel_not_black(img, x, y)
    px = img.pixel_color(x, y)
    if px.red &gt; 16448 or px.green &gt; 16448 or px.blue &gt; 16448
        return true
    end
end

def locate_left(img)
    (0..img.rows).each do |i|
        if pixel_not_black(img, i, i)
            @x = i
            break
        end
    end
    locate_y(img, 0, @x)
end

def locate_right(img)
    x = img.columns/2 #雙螢幕
    (0..x).each do |i|
        if pixel_not_black(img, x - i, i)
            @x = x - i
            break
        end
    end
    locate_y(img, x, @x)
end

def locate_y(img, st, x)
    (0..img.rows).each do |i|
        y = (i - st).abs
        if pixel_not_black(img, x, y)
            return x, y
        end
    end
end

#screenshot = Magick::Image.capture{ self.filename = "root" }
img = Magick::ImageList.new.read("/tmp/image/base.jpg")
lx, ly = locate_left(img)
rx, ry = locate_right(img)
img.crop!(lx, ly, rx-lx, ry-ly)
img.write("/tmp/image/base1.jpg")
</code></pre>
]]></content>
  </entry>
  
 </feed>
