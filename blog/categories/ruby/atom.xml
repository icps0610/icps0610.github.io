<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | icps]]></title>
  <link href="http://icps0610.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://icps0610.github.io/"/>
  <updated>2016-07-11T14:53:40+08:00</updated>
  <id>http://icps0610.github.io/</id>
  <author>
    <name><![CDATA[icps]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[因數分解]]></title>
    <link href="http://icps0610.github.io/blog/2016/07/11/factor/"/>
    <updated>2016-07-11T13:09:39+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/07/11/factor</id>
    <content type="html"><![CDATA[<pre><code class="ruby">def factor(n,f=2,result="")
  if n == 1 and (not result == "" and f &gt;= n/2)
    return result.chop
  elsif n%f == 0
    result+=f.to_s+"×"
    (n/f)%f == 0 ? factor(n/f,f,result) : factor(n/f,f+1,result)
  else
    factor(n,f+1,result)
  end
end

def reorganize(n)
  #Array項目內重複次數
  repeat=n.split("×").each_with_object(Hash.new(0)){|m,h|h[m]+= 1}
  return repeat.to_a.map{|x,y| "#{x}**#{y} × " }.join.chop.chop.chop
end
num = 29475
puts factor(num)
puts reorganize(factor(num))

# 3×3×5×5×131
# 3**2 × 5**2 × 131**1
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ping_log]]></title>
    <link href="http://icps0610.github.io/blog/2016/07/08/ping/"/>
    <updated>2016-07-08T16:10:15+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/07/08/ping</id>
    <content type="html"><![CDATA[<p><img src="/images/ping.png" alt="ping.png" /></p>

<pre><code class="ruby">#!/usr/bin/env ruby
# encoding: utf-8
require 'colorize'
require '/data/ruby/chinese_num/chinese_num.rb'

def restore(where)
  if @break == 1
    `espeak -vzh '#{where}恢復' -s 250`
    @break = 0
  end
end

def record(time)
  `echo #{Time.now.strftime("%H:%M:%S")}, #{time} &gt;&gt; /tmp/ping.log`
end

def delay(ip,where,alert)
  time = `ping #{ip} -c 1 | awk '{print $7}' | grep time`.scan(/time=(.*)/).join.to_f
  if time == 0.0
    `espeak -vzh '#{where}斷線' -s 250`
    record(-10000.0)
    @break=1
  else
    puts time.to_s.blue+"   "+ip
    record(time)
    restore(where)
    if time &gt; alert
      `espeak -vzh '#{where}延遲#{Chinese_num.transform(time.to_i)}秒' -s 250`
    end
  end
end

def gnuplot
  tmp = IO.binread("/tmp/ping.log")
  count = tmp.split("\n").count
  count = 256 if count &lt; 256

  log_start = tmp.split("\n").first.scan(/(.*),.*/).join
  log_end = tmp.split("\n").last.scan(/(.*),.*/).join

  file = []
  file &lt;&lt; "set grid y"
  file &lt;&lt; "set yrange [0:]"
  file &lt;&lt; "set ylabel 'ms'"
  file &lt;&lt; "set xdata time"
  file &lt;&lt; "set timefmt '%H:%M:%S'"
  file &lt;&lt; "set xrange ['#{log_start}':'#{log_end}']"
  file &lt;&lt; "set format x '%H:%M:%S'"
  file &lt;&lt; "set xlabel '#{log_start} ~ #{log_end}'"
  file &lt;&lt; "set xtics 3600"
  file &lt;&lt; "set terminal png size #{count*5},480"
  file &lt;&lt; "set output '/tmp/ping.png'"
  file &lt;&lt; "set border 0"
  file &lt;&lt; "set style data lines"
  file &lt;&lt; "set style line 1 linecolor rgb '#0060ad' linetype 1 linewidth 1"
  file &lt;&lt; "plot '/tmp/ping.log' using 1:2 notitle linestyle 1"

  IO.binwrite('/tmp/ping.p',file.map{|i|i+"\r\n"}.join)
  system "gnuplot &lt; /tmp/ping.p"
  system "kill `ps aux | grep /usr/bin/display.im6 | awk '{print $2}'`"
end

@break = 0
@count = 0
loop do
  gnuplot if @count%120 == 0
  delay("168.95.1.1","中華電信",1000)
  sleep 5
  @count+=1
end
</code></pre>

<h4>語音</h4>

<p><code>espeak -vzh '測試'</code>  <a href="/blog/2016/06/17/espeak/">espeak</a></p>

<h4>繪圖</h4>

<p><code>gnuplot</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[產生隨機資料]]></title>
    <link href="http://icps0610.github.io/blog/2016/07/06/faker/"/>
    <updated>2016-07-06T11:56:35+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/07/06/faker</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/stympy/faker">https://github.com/stympy/faker</a></p>

<p><code>gem install faker</code>
<code>ruby
Faker::Name.first_name    
Faker::Internet.email
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/21/google/"/>
    <updated>2016-06-21T13:16:48+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/21/google</id>
    <content type="html"><![CDATA[<pre><code class="ruby"># encoding: UTF-8
require 'nokogiri'
require 'open-uri'
require 'json'
class Gmap

  def initialize
    if ARGV.count == 2
      find_A_B( find( ARGV[0] , "A" , "red" , 18) , find( ARGV[1] , "B" , "blue" , 18 ) )
    elsif ARGV.count == 1
      find( ARGV[0] , "A" , "red" , 18)
      find( ARGV[0] , "AA" , "red" , 16)
      `montage /tmp/imageA1.jpg /tmp/imageAA1.jpg -geometry +0+0 all.jpg`
    else
      puts 'input one or two address'
    end
  end

 def find(address , label , color , zoom )
    puts "downloading.."+ address
    url = "http://maps.googleapis.com/maps/api/geocode/json?address=" +address
    doc = Nokogiri::HTML(open( URI.escape(url)),nil,nil).text.match(/location" : {\n.*"lat" : (.*),\n.*"lng" : (.*)/)
    #doc = JSON.parse(Nokogiri::HTML(open( URI.escape(url)),nil,nil).text)["results"][0]["geometry"]["location"]
    #lat = doc["lat"]
    #lng = doc["lng"]
    `wget -q \"https://maps.googleapis.com/maps/api/staticmap?center=#{doc[1]},#{doc[2]}&amp;markers=color:#{color}%7Clabel:#{label}%7C#{doc[1]},#{doc[2]}&amp;zoom=#{zoom}&amp;size=1024x1024&amp;scale=2&amp;language=zh-tw&amp;maptype=hybrid\" -O /tmp/image#{label}.jpg`
    `convert /tmp/image#{label}.jpg -bordercolor white -border 5 /tmp/image#{label}1.jpg`
    return [ doc[1] , doc[2] ]
  end

  def find_A_B( a , b )
    puts "downloading..two place"
    cen = [ (a[0].to_f+b[0].to_f)/2 , (a[1].to_f+b[1].to_f)/2 ]
    `wget -q \"https://maps.googleapis.com/maps/api/staticmap?center=#{cen[0]},#{cen[1]}&amp;markers=color:red%7Clabel:A%7C#{a[0]},#{a[1]}&amp;markers=color:blue%7Clabel:B%7C#{b[0]},#{b[1]}&amp;size=1024x1024&amp;scale=2&amp;language=zh-tw&amp;maptype=hybrid\" -O /tmp/imageAB.jpg`
    `convert /tmp/imageAB.jpg -bordercolor white -border 5 /tmp/imageAB1.jpg`
    `montage /tmp/imageA1.jpg /tmp/imageB1.jpg -tile 1x2 -geometry +0+0 -resize 640x640 /tmp/output.jpg`
    `montage /tmp/imageAB1.jpg /tmp/output.jpg -geometry +0+0 all.jpg`
  end
end
Gmap.new
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qrcode]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/19/qrcode/"/>
    <updated>2016-06-19T23:54:44+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/19/qrcode</id>
    <content type="html"><![CDATA[<pre><code class="ruby">require 'rqrcode_png'
require "mini_magick"
text="test"
input_image="3.jpg"
#產生Qrcode
qr = RQRCode::QRCode.new( text, :size =&gt; 6, :level =&gt; :m )
png = qr.to_img.resize(300, 300).save("qr.png")
#合併照片
qr_png = MiniMagick::Image.open("qr.png")
image = MiniMagick::Image.open(input_image)
image.resize "80x80"
result = qr_png.composite(image) do |c|
  c.compose "Over"
  c.geometry "+#{((300-image.width.to_i)/2).to_s}+#{((300-image.height.to_i)/2).to_s}"
end
result.write "qr.jpg"
</code></pre>

<h3>換顏色</h3>

<pre><code class="ruby"> #/usr/local/lib/ruby/gems/2.3.0/gems/rqrcode_png-0.1.5/lib/rqrcode_png/image.rb
 #3 
 BLACK = ::ChunkyPNG::Color.rgba(255,91,145,255) #pink
</code></pre>
]]></content>
  </entry>
  
 </feed>
