<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | icps]]></title>
  <link href="http://icps0610.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://icps0610.github.io/"/>
  <updated>2016-07-05T22:13:56+08:00</updated>
  <id>http://icps0610.github.io/</id>
  <author>
    <name><![CDATA[icps]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Google]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/21/google/"/>
    <updated>2016-06-21T13:16:48+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/21/google</id>
    <content type="html"><![CDATA[<pre><code class="ruby"># encoding: UTF-8
require 'nokogiri'
require 'open-uri'
require 'json'
class Gmap

  def initialize
    if ARGV.count == 2
      find_A_B( find( ARGV[0] , "A" , "red" , 18) , find( ARGV[1] , "B" , "blue" , 18 ) )
    elsif ARGV.count == 1
      find( ARGV[0] , "A" , "red" , 18)
      find( ARGV[0] , "AA" , "red" , 16)
      `montage /tmp/imageA1.jpg /tmp/imageAA1.jpg -geometry +0+0 all.jpg`
    else
      puts 'input one or two address'
    end
  end

 def find(address , label , color , zoom )
    puts "downloading.."+ address
    url = "http://maps.googleapis.com/maps/api/geocode/json?address=" +address
    doc = Nokogiri::HTML(open( URI.escape(url)),nil,nil).text.match(/location" : {\n.*"lat" : (.*),\n.*"lng" : (.*)/)
    #doc = JSON.parse(Nokogiri::HTML(open( URI.escape(url)),nil,nil).text)["results"][0]["geometry"]["location"]
    #lat = doc["lat"]
    #lng = doc["lng"]
    `wget -q \"https://maps.googleapis.com/maps/api/staticmap?center=#{doc[1]},#{doc[2]}&amp;markers=color:#{color}%7Clabel:#{label}%7C#{doc[1]},#{doc[2]}&amp;zoom=#{zoom}&amp;size=1024x1024&amp;scale=2&amp;language=zh-tw&amp;maptype=hybrid\" -O /tmp/image#{label}.jpg`
    `convert /tmp/image#{label}.jpg -bordercolor white -border 5 /tmp/image#{label}1.jpg`
    return [ doc[1] , doc[2] ]
  end

  def find_A_B( a , b )
    puts "downloading..two place"
    cen = [ (a[0].to_f+b[0].to_f)/2 , (a[1].to_f+b[1].to_f)/2 ]
    `wget -q \"https://maps.googleapis.com/maps/api/staticmap?center=#{cen[0]},#{cen[1]}&amp;markers=color:red%7Clabel:A%7C#{a[0]},#{a[1]}&amp;markers=color:blue%7Clabel:B%7C#{b[0]},#{b[1]}&amp;size=1024x1024&amp;scale=2&amp;language=zh-tw&amp;maptype=hybrid\" -O /tmp/imageAB.jpg`
    `convert /tmp/imageAB.jpg -bordercolor white -border 5 /tmp/imageAB1.jpg`
    `montage /tmp/imageA1.jpg /tmp/imageB1.jpg -tile 1x2 -geometry +0+0 -resize 640x640 /tmp/output.jpg`
    `montage /tmp/imageAB1.jpg /tmp/output.jpg -geometry +0+0 all.jpg`
  end
end
Gmap.new
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qrcode]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/19/qrcode/"/>
    <updated>2016-06-19T23:54:44+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/19/qrcode</id>
    <content type="html"><![CDATA[<pre><code class="ruby">require 'rqrcode_png'
require "mini_magick"
text="test"
input_image="3.jpg"
#產生Qrcode
qr = RQRCode::QRCode.new( text, :size =&gt; 6, :level =&gt; :m )
png = qr.to_img.resize(300, 300).save("qr.png")
#合併照片
qr_png = MiniMagick::Image.open("qr.png")
image = MiniMagick::Image.open(input_image)
image.resize "80x80"
result = qr_png.composite(image) do |c|
  c.compose "Over"
  c.geometry "+#{((300-image.width.to_i)/2).to_s}+#{((300-image.height.to_i)/2).to_s}"
end
result.write "qr.jpg"
</code></pre>

<h3>換顏色</h3>

<pre><code class="ruby"> #/usr/local/lib/ruby/gems/2.3.0/gems/rqrcode_png-0.1.5/lib/rqrcode_png/image.rb
 #3 
 BLACK = ::ChunkyPNG::Color.rgba(255,91,145,255) #pink
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSS]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/18/rss/"/>
    <updated>2016-06-18T20:18:58+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/18/rss</id>
    <content type="html"><![CDATA[<pre><code class="ruby">require 'rss'
require 'open-uri'

url = 'http://www.appledaily.com.tw/rss/newcreate/kind/rnews/type/new'
open(url) do |rss|
  feed = RSS::Parser.parse(rss)
  feed.items.each do |item|
    puts "Title: #{item.title}"
  end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenSSL-AES256]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/18/openssl-aes256/"/>
    <updated>2016-06-18T20:10:17+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/18/openssl-aes256</id>
    <content type="html"><![CDATA[<pre><code class="ruby"># encoding: utf-8
require "base64"

def aes_encrypt(data)
  cipher = OpenSSL::Cipher::AES256.new(:CBC)
  cipher.encrypt
  cipher.key = KEY#cipher.random_key
  cipher.iv = IV#cipher.random_iV
  encrypt = cipher.update(data) + cipher.final
  return Base64.encode64(encrypt).chomp
end

def aes_decrypt(encrypt)
  encrypt = Base64.decode64(encrypt)
  decipher = OpenSSL::Cipher::AES256.new(:CBC)
  decipher.decrypt
  decipher.key = KEY
  decipher.iv  = IV
  decrypt = decipher.update(encrypt) + decipher.final
  return decrypt
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Matsu]]></title>
    <link href="http://icps0610.github.io/blog/2016/06/18/matsu/"/>
    <updated>2016-06-18T03:43:48+08:00</updated>
    <id>http://icps0610.github.io/blog/2016/06/18/matsu</id>
    <content type="html"><![CDATA[<h4>airport</h4>

<pre><code class="ruby">require 'nokogiri'
require 'net/http'
def airport
  url = Net::HTTP.get(URI.parse "http://www.matsu-news.gov.tw/")
  doc = Nokogiri::HTML( url, nil, 'big5' )
  array= doc.xpath("//td")[28].text.split(" ").drop(1)
  array.map do |x|
    not x =~ /◎/ ? x.split("-").map{|i|i} : x
  end
  array.take(array.count-3).map{|i|i+"\n"}.to_a.join
end
</code></pre>

<h2>matsu</h2>

<pre><code class="ruby">require 'nokogiri'
require 'net/http'
url = Net::HTTP.get(URI.parse "http://www.matsu.idv.tw/index_main.php")
@doc = Nokogiri::HTML(url, nil, nil )

def matsu_ship
  all_title=""
  board=@doc.xpath("//table[contains(@width, '100%') and contains(@border, '0') and contains(@cellspacing, '0') and contains(@cellpadding, '4')]")[0].text.split("\n\n 航班公告\n\n\n").to_a.join.split("  ")
  if not board[0].scan(/.*無航班資料.*/).count == 1
    (0..board.count-2).each do |i|
      link=@doc.xpath("//table[contains(@width, '100%') and contains(@border, '0') and contains(@cellspacing, '0') and contains(@cellpadding, '4')]//a")[i]['href']
      all_title+=board[i]+"\n"+"http://www.matsu.idv.tw/"+link+"\n"
    end
  else
    return "今日無航班資料"
  end
  return all_title
end

def matsu_news_list
  title= @doc.xpath("//ul[@id='news_list']").text.split("\n").delete_if {|i|i==""}.map{|i|i.strip+"\n"}
  link=@doc.xpath("//ul[@id='news_list']//a").map{|i|i['href']}.uniq
  title_link(title,link)
end
def matsu_talk
  link =@doc.xpath("//td[@height='22' and @class='largetext']//a").map{|i|i['href']}.uniq.take(7)
  title=@doc.xpath("//td[@height='22' and @class='largetext']").text.split("\n").drop(1).take(7).map{|i|i+"\n"}
  title_link(title,link)
end
def title_link(title,link)
  result=[]
  title.each_index do |i|
    result &lt;&lt; title[i].strip+"\n"
    result &lt;&lt; 'http://www.matsu.idv.tw/'+link[i]+"\n"
  end
  result.to_a.join
end
puts matsu_ship
puts matsu_news_list
puts matsu_talk
</code></pre>
]]></content>
  </entry>
  
 </feed>
