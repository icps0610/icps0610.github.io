<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | icps]]></title>
  <link href="https://icps0610.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://icps0610.github.io/"/>
  <updated>2019-10-09T16:33:04+08:00</updated>
  <id>https://icps0610.github.io/</id>
  <author>
    <name><![CDATA[icps]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[getWeekNumber]]></title>
    <link href="https://icps0610.github.io/blog/2019/08/06/getweeknumber/"/>
    <updated>2019-08-06T00:49:19+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/08/06/getweeknumber</id>
    <content type="html"><![CDATA[<pre><code class="go">func leapYear(y int) bool {
    if (y%4 == 0 &amp;&amp; y%100 != 0) || (y%400 == 0 &amp;&amp; y%3200 != 0) {
        return true
    }
    return false
}
func getWeek(y, m, d int) int {
    monthTable := []int{6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}
    centuryTable := []int{0, 5, 3, 1}
    monthValue := monthTable[m-1]
    yearValue := y % 100
    yearOver := yearValue / 4
    centuryValue := centuryTable[(y/100)%4]
    w := d + monthValue + yearValue + yearOver + centuryValue
    if leapYear(y) &amp;&amp; m &lt;= 2 {
        w -= 1
    }
    return w % 7
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Package]]></title>
    <link href="https://icps0610.github.io/blog/2019/05/21/package/"/>
    <updated>2019-05-21T23:13:00+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/05/21/package</id>
    <content type="html"><![CDATA[<h5>beauty print</h5>

<p><code>github.com/go-ffmt/ffmt</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go]]></title>
    <link href="https://icps0610.github.io/blog/2019/05/15/go/"/>
    <updated>2019-05-15T15:34:10+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/05/15/go</id>
    <content type="html"><![CDATA[<h3>cmd</h3>

<h6>toEXE</h6>

<pre><code class="">windoes/linux amd64/386
GOOS=windows GOARCH=amd64 go build -o hello.exe hello.go
</code></pre>

<h6>convert</h6>

<p><code>https://mholt.github.io/curl-to-go/</code><br/>
<code>https://mholt.github.io/json-to-go/</code>
<code>https://github.com/Terry-Mao/paint</code></p>

<h6>argv</h6>

<p><code>os.Args[1]</code></p>

<h5>run command</h5>

<pre><code class="go">cmd := exec.Command("ipconfig")
_, err := cmd.CombinedOutput()
if err != nil {
    fmt.Println(err)
}
</code></pre>

<h3>ipconfig</h3>

<pre><code class="go">ifaces, _ := net.Interfaces()
// handle err
for _, i := range ifaces {
    addrs, _ := i.Addrs()
    // handle err
    for _, addr := range addrs {
        var ip net.IP
        switch v := addr.(type) {
        case *net.IPNet:
            ip = v.IP
        case *net.IPAddr:
            ip = v.IP
        }
        fmt.Println(ip)
    }
}
</code></pre>

<h6>curl</h6>

<pre><code class="go">import (
    "io/ioutil"
)
resp, err := http.Get(url)
if err != nil {
    // handle err
}
defer resp.Body.Close()
body, e := ioutil.ReadAll(resp.Body)

if e != nil {
   // handle err
}
string(body)
</code></pre>

<h6>input</h6>

<pre><code class="go">reader := bufio.NewReader(os.Stdin)
fmt.Print("file: ")
ipt, _ := reader.ReadString('\n')
input := strings.TrimSuffix(ipt, "\n")
return input
</code></pre>

<h5>continue</h5>

<pre><code class="go">fmt.Print("Press 'Enter' to continue...")
bufio.NewReader(os.Stdin).ReadBytes('\n')
</code></pre>

<h6>IO</h6>

<pre><code class="go">
func writeLines(lines []string, path string) {
    file, err := os.Create(path)
    if err != nil {
        fmt.Println(err)
    }
    defer file.Close()
    for _, line := range lines {
        file.WriteString(line + "\n")
    }
}

func readfile(path string) ([]string, error) {
    file, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer file.Close()
    var lines []string
    line := bufio.NewScanner(file)
    for line.Scan() {
        lines = append(lines, line.Text())
    }
    return lines, line.Err()
}

//win utf-16 le to utf-8
import "github.com/malexdev/utfutil"
d, _ := utfutil.ReadFile("txt", utfutil.UTF8)
c := string(d)
</code></pre>

<h6>Json</h6>

<pre><code class="go">imprt "encoding/json"
type Employee struct {
    Name string
    Age  int
}

type List struct {
    ID []*Employee
}

func writeJson(fname string, data []Employee) {
    file, _ := json.MarshalIndent(data, "", " ")
    _ = ioutil.WriteFile(fname, file, 0644)
}
func readJson(fname string) []Employee {
    file, _ := ioutil.ReadFile(fname)
    reaJson := []Employee{}
    _ = json.Unmarshal([]byte(file), &amp;reaJson)
    return reaJson
}
fname := "user.json"
writeJson(fname, p)
reaJson := readJson(fname)
ffmt.Puts(reaJson[0].Name)
</code></pre>

<h6>filepath</h6>

<pre><code class="go">import "path/filepath"
dir, file := filepath.Split("/go/go.mod")

fmt.Println(dir)
fmt.Println(file)
</code></pre>

<h6>fileExist</h6>

<pre><code class="go">func fileExist(file string) bool {
  if _, err := os.Stat(file); err != nil {
    if os.IsNotExist(err) {
      return false
    }
  }
  return true
}
</code></pre>

<h6>exec</h6>

<pre><code class="go">cmd := exec.Command("sleep", "1")
err := cmd.Run()
</code></pre>

<h3>debug</h3>

<h6>type class</h6>

<pre><code class="go  ">import "reflect"  
fmt.Println(reflect.TypeOf(doc))

import "github.com/go-ffmt/ffmt"
ffmt.P(m)  // type
ffmt.Puts  
ffmt.Pjson 
</code></pre>

<h6>ignore not used</h6>

<pre><code class="go">import (
    _ "fmt" //imported and not used
 )
</code></pre>

<h6>skip declared</h6>

<pre><code class="go">i := 1 
_ = i
</code></pre>

<h6>run time</h6>

<pre><code class="go">start := time.Now()
time.Now().Sub(start)
</code></pre>

<h5>screen</h5>

<pre><code class="go">import "github.com/inancgumus/screen"

func cleanScreen() {
    screen.Clear()
    screen.MoveTopLeft()
}
</code></pre>

<h3>time</h3>

<h6>time_format</h6>

<pre><code class="go">func timeFormat(t time.Time) string {
    return fmt.Sprintf("%d-%02d-%02d %02d:%02d:%02d", t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second())
}
today := time.Now()
timeFormat(today)
</code></pre>

<h6>sleep</h6>

<pre><code class="go">time.Sleep(1 * time.Second)

func sleep(t int) {
    time.Sleep(time.Duration(t) * time.Millisecond)
}
</code></pre>

<h3>string</h3>

<h6>strip</h6>

<p><code>strings.TrimSpace(str)</code></p>

<h6>sting <-> int</h6>

<pre><code class="go">i, err := strconv.Atoi(s)
if err ! = nil {
    //
}
s := strconv.Itoa(i)
</code></pre>

<h6>fill_zero</h6>

<pre><code class="go">func rjust(s string, n int, fill string) string {
    return strings.Repeat(fill, n-len(s)) + s
}
func ljust(s string, n int, fill string) string {
    return s + strings.Repeat(fill, n-len(s))
}
</code></pre>

<h6>regexp</h6>

<pre><code class="go">match, _ := regexp.MatchString(keyword, str)
r, _ := regexp.Compile(keyword)

//scan
re := regexp.MustCompile(keyword)
match := re.FindStringSubmatch(l)
if len(match) &gt; 0 {
    fmt.Println(match[1])
}
</code></pre>

<h6>chr <-> ord</h6>

<pre><code class="go">func ord(s string) int {
    return int([]byte(s)[0])
}
func chr(i int) string {
    return fmt.Sprintf("%c", rune(i))
}
</code></pre>

<h6>string reverse</h6>

<pre><code class="go">func strReverse(str string) string {
    comb := ""
    for i := len(str) - 1; i &gt;= 0; i-- {
        comb += string(str[i])
    }
    return comb
}
</code></pre>

<h6>index</h6>

<pre><code class="go">func strIndex(str string, bstr string) int {
    arr := strings.Split(str, "")
    for i, e := range arr {
        if bstr == string(e) {
            return i
        }
    }
    return -1
}
func strIndexS(str string, bstr string) []int {
    arr := strings.Split(str, "")
    is := []int{}
    for i, e := range arr {
        if bstr == string(e) {
            is = append(is, i)
        }
    }
    return is
}
</code></pre>

<h5>slice ch string</h5>

<pre><code class="go">func sliceChString(ch string, start int, end int) string {
    var size int
    var chs = []rune(ch)
    if len(chs) &gt; end &amp;&amp; end &gt; start {
        result := ""
        for _, e := range chs {
            str := string(e)
            if ord(str) &gt; 127 {
                size += 2
            } else {
                size += 1
            }
            result += str
            if size &gt; (end-start)*2 {
                break
            }
        }
        return result
    }
    return ch
}
</code></pre>

<h3>array</h3>

<h6>eachSlice N part</h6>

<pre><code class="go">func eachSlice(arr []string, l int) [][]string {
    var ar [][]string
    size := len(arr)
    for i := 0; i &lt; size; i = i + l {
        j := i + l
        if j &gt; size {
            j = size
        }
        fmt.Println(len(arr[i:j]))
        ar = append(ar, arr[i:j])
    }
    return ar
}
</code></pre>

<h6>index</h6>

<pre><code class="go">func arrIndex(arr []string, str string) int {
    for i, e := range arr {
        if str == e {
            return i
        }
    }
    return -1
}
func arrIndexS(arr []string, str string) []int {
    is := []int{}
    for i, e := range arr {
        if str == e {
            is = append(is, i)
        }
    }
    return is
}
</code></pre>

<h6>bubbleSort</h6>

<pre><code class="go">func bubbleSort(arr []int) {
    size := len(arr)
    for i := 0; i &lt; size; i++ {
        for j := 1; j &lt; size; j++ {
            if arr[j] &gt; arr[j-1] {
                arr[j], arr[j-1] = arr[j-1], arr[j]
            }
        }
    }
}
</code></pre>

<h6>duplicate</h6>

<pre><code class="go">type Count struct {
    id    string
    count int
}
func arrayDuplicate(arr []string) []Count {
    cs := make(map[string]int)
    for _, e := range arr {
        _, exist := cs[e]
        if exist {
            cs[e] += 1
        } else {
            cs[e] = 1
        }
    }
    count := []Count{}
    for cc := range cs {
        c := Count{str: cc, count: cs[cc]}
        count = append(count, c)
    }
    bubbleSort(count)
    return count
}
</code></pre>

<h6>sub</h6>

<pre><code class="go">func arrSub(arr1 []int, arr2 []int) []int {
    r := []int{}
    for _, e1 := range arr1 {
        if !arrInclude(arr2, e1) {
            r = append(r, e1)
        }
    }
    return r
}
</code></pre>

<h6>include</h6>

<pre><code class="go">func arrInclude(arr []int, str int) bool {
    for _, e := range arr {
        if str == e {
            return true
        }
    }
    return false
}
func arr1InclueArr2(arr1 []int, arr2 []int) bool {
    for _, e := range arr1 {
        if !reflect.DeepEqual(e, arr2) {
            return false
        }

    }
    return true
}
</code></pre>

<h5>Equal</h5>

<p><code>reflect.DeepEqual(a, b)</code></p>

<h3>math</h3>

<h6>power</h6>

<pre><code class="go">import "math"
math.Pow(2, 5)
</code></pre>

<h6>bit</h6>

<pre><code class="go">n, err := strconv.ParseUint(val, 16, 32)
if err != nil {
    panic(err)
}
</code></pre>

<h6>d</h6>

<pre><code class="go">math.Ceil(0.2)
math.Floor(0.2)
</code></pre>

<h5>even odd</h5>

<pre><code class="go">func evenBool(i int) bool {
    return i%2 == 0
}
func oddBool(i int) bool {
    return i%2 != 0
}
</code></pre>

<h6>toHex</h6>

<pre><code class="go">func toHex(i int) string {
    return fmt.Sprintf("%x", i)
}
</code></pre>

<h6>rand</h6>

<pre><code class="go">import "math/rand"

rand.Seed(time.Now().UnixNano())
rand.Intn(100)
</code></pre>

<h3>image</h3>

<pre><code class="go">func rgbtoHex(i uint32) string {
    hex := fmt.Sprintf("%x", i)
    return hex[0:2]
}

func rgbaToPixel(r uint32, g uint32, b uint32, a uint32) string {
    return rgbtoHex(r) + rgbtoHex(g) + rgbtoHex(b)
}
img, _, err := image.Decode(file)

bounds := img.Bounds()
width, height := bounds.Max.X, bounds.Max.Y

pixel := rgbaToPixel(img.At(x, y).RGBA())
</code></pre>
]]></content>
  </entry>
  
 </feed>
