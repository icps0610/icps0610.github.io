<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Golang | icps]]></title>
  <link href="https://icps0610.github.io/blog/categories/golang/atom.xml" rel="self"/>
  <link href="https://icps0610.github.io/"/>
  <updated>2020-03-21T13:44:48+08:00</updated>
  <id>https://icps0610.github.io/</id>
  <author>
    <name><![CDATA[icps]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[secureRandom]]></title>
    <link href="https://icps0610.github.io/blog/2019/10/25/securerandom/"/>
    <updated>2019-10-25T02:01:38+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/10/25/securerandom</id>
    <content type="html"><![CDATA[<pre><code class="go">func chrTable() string {
    var aZ string
    for i := 65; i &lt;= 90; i++ {
        aZ += string(rune(i))
    }
    for i := 97; i &lt;= 122; i++ {
        aZ += string(rune(i))
    }
    for i := 0; i &lt;= 9; i++ {
        aZ += strconv.Itoa(i)
    }
    return aZ
}

func secureRandom(n int) string {
    rand.Seed(time.Now().UnixNano())
    var str string
    table := chrTable()
    for i := 0; i &lt; n; i++ {
        r := rand.Intn(len(table))
        str += string(table[r])
    }
    return str
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[getWeekNumber]]></title>
    <link href="https://icps0610.github.io/blog/2019/08/06/getweeknumber/"/>
    <updated>2019-08-06T00:49:19+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/08/06/getweeknumber</id>
    <content type="html"><![CDATA[<pre><code class="go">func leapYear(y int) bool {
    if (y%4 == 0 &amp;&amp; y%100 != 0) || (y%400 == 0 &amp;&amp; y%3200 != 0) {
        return true
    }
    return false
}
func getWeek(y, m, d int) int {
    monthTable := []int{6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4}
    centuryTable := []int{0, 5, 3, 1}
    monthValue := monthTable[m-1]
    yearValue := y % 100
    yearOver := yearValue / 4
    centuryValue := centuryTable[(y/100)%4]
    w := d + monthValue + yearValue + yearOver + centuryValue
    if leapYear(y) &amp;&amp; m &lt;= 2 {
        w -= 1
    }
    return w % 7
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Package]]></title>
    <link href="https://icps0610.github.io/blog/2019/05/21/package/"/>
    <updated>2019-05-21T23:13:00+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/05/21/package</id>
    <content type="html"><![CDATA[<h5>beauty print</h5>

<p><code>github.com/go-ffmt/ffmt</code></p>

<h4>igo</h4>

<p><code>go get github.com/sbinet/go-eval/</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Go]]></title>
    <link href="https://icps0610.github.io/blog/2019/05/15/go/"/>
    <updated>2019-05-15T15:34:10+08:00</updated>
    <id>https://icps0610.github.io/blog/2019/05/15/go</id>
    <content type="html"><![CDATA[<h3>cmd</h3>

<h6>toEXE</h6>

<pre><code class="">windoes/linux amd64/386
GOOS=windows GOARCH=amd64 go build -o hello.exe hello.go
</code></pre>

<h6>convert</h6>

<p><code>https://mholt.github.io/curl-to-go/</code><br/>
<code>https://mholt.github.io/json-to-go/</code>
<code>https://github.com/Terry-Mao/paint</code></p>

<h6>argv</h6>

<p><code>os.Args[1]</code></p>

<h5>run command</h5>

<pre><code class="go">cmd := exec.Command("ipconfig")
_, err := cmd.CombinedOutput()
if err != nil {
    fmt.Println(err)
}
</code></pre>

<h5>ipconfig</h5>

<pre><code class="go">ifaces, _ := net.Interfaces()
// handle err
for _, i := range ifaces {
    addrs, _ := i.Addrs()
    // handle err
    for _, addr := range addrs {
        var ip net.IP
        switch v := addr.(type) {
        case *net.IPNet:
            ip = v.IP
        case *net.IPAddr:
            ip = v.IP
        }
        fmt.Println(ip)
    }
}
</code></pre>

<h5>screenShot</h5>

<pre><code class="go">"github.com/kbinani/screenshot"
"github.com/oliamb/cutter"
"image"
"image/png"

func getScreenshot(px, py, width, height int, imageName string) {
    bounds := screenshot.GetDisplayBounds(0)

    img, err := screenshot.CaptureRect(bounds)
    if err != nil {
        fmt.Println(err)
    }
    file, _ := os.Create(imageName)
    defer file.Close()

    croppedImg, err := cutter.Crop(img, cutter.Config{
        Anchor: image.Point{px, py},
        Width:  width,
        Height: height,
    })

    png.Encode(file, croppedImg)
    sleep(delay)
}
</code></pre>

<pre><code class="go">"github.com/oliamb/cutter"
"github.com/sclevine/agouti"
"image"
"image/png"
func getScreenshot(page *agouti.Page, px, py, width, height int, imageName string) {
    page.Screenshot(imageName)

    f, err := os.Open(imageName)
    if err != nil {
        fmt.Println("Cannot open file", err)
    }
    img, _, err := image.Decode(f)
    if err != nil {
        fmt.Println("Cannot decode image:", err)
    }
    file, _ := os.Create(imageName)
    defer file.Close()

    croppedImg, err := cutter.Crop(img, cutter.Config{
        Anchor: image.Point{px, py},
        Width:  width,
        Height: height,
    })

    png.Encode(file, croppedImg)
    sleep(delay)
}
</code></pre>

<h6>curl</h6>

<pre><code class="go">import (
    "io/ioutil"
)
resp, err := http.Get(url)
if err != nil {
    // handle err
}
defer resp.Body.Close()
body, e := ioutil.ReadAll(resp.Body)

if e != nil {
   // handle err
}
string(body)
</code></pre>

<h6>input</h6>

<pre><code class="go">reader := bufio.NewReader(os.Stdin)
fmt.Print("file: ")
ipt, _ := reader.ReadString('\n')
input := strings.TrimSuffix(ipt, "\n")
return input
</code></pre>

<h5>continue</h5>

<pre><code class="go">fmt.Print("Press 'Enter' to continue...")
bufio.NewReader(os.Stdin).ReadBytes('\n')
</code></pre>

<h6>IO</h6>

<pre><code class="go">data := []byte("hello\ngo\n")
err := ioutil.WriteFile("/tmp/data", data, 0644)


func writeLines(lines []string, path string) {
    file, err := os.Create(path)
    if err != nil {
        fmt.Println(err)
    }
    defer file.Close()
    for _, line := range lines {
        file.WriteString(line + "\n")
    }
}

import(
    "golang.org/x/text/encoding/traditionalchinese"
    "golang.org/x/text/transform"
)

func readfile(path string) []string {
    file, err := os.Open(path)
    if err != nil {
        fmt.Println(err)
    }
    defer file.Close()
    var lines []string
    line := bufio.NewScanner(file)
    for line.Scan() {
        //str, _, _ := transform.String(traditionalchinese.Big5.NewDecoder(), str2)
        //str2, _, _ := transform.String(traditionalchinese.Big5.NewEncoder(), str)
        lines = append(lines, line.Text())
    }
    return lines
}


//win utf-16 le to utf-8
import "github.com/malexdev/utfutil"
d, _ := utfutil.ReadFile("txt", utfutil.UTF8)
c := string(d)


func appendFile(path string, data []string) {
    f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        log.Println(err)
    }
    defer f.Close()

    for _, line := range data {
        f.WriteString(line + "n")
    }

}
</code></pre>

<h6>Json</h6>

<pre><code class="go">imprt "encoding/json"
type Employee struct {
    Name string
    Age  int
}

type List struct {
    ID []*Employee
}

func writeJson(fname string, data []Employee) {
    file, _ := json.MarshalIndent(data, "", " ")
    _ = ioutil.WriteFile(fname, file, 0644)
}
func readJson(fname string) []Employee {
    file, _ := ioutil.ReadFile(fname)
    reaJson := []Employee{}
    _ = json.Unmarshal([]byte(file), &amp;reaJson)
    return reaJson
}
fname := "user.json"
writeJson(fname, p)
reaJson := readJson(fname)
ffmt.Puts(reaJson[0].Name)
</code></pre>

<pre><code class="go">var c map[string][]map[string]interface{}
var cs []string
json.Unmarshal([]byte(str), &amp;c)

t := c["content_elements"]

for _, e := range t {
    c := e["content"]
    if c != nil {
        cs = append(cs, fmt.Sprintf("%s", c))
    }
}
return cs
</code></pre>

<h5>pwd</h5>

<pre><code class="go">import(
    "os"
    "path/filepath"
)

dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
dir, err := os.Getwd()
</code></pre>

<h6>filepath</h6>

<pre><code class="go">import "path/filepath"
dir, file := filepath.Split("/go/go.mod")

fmt.Println(dir)
fmt.Println(file)
</code></pre>

<h6>fileExist</h6>

<pre><code class="go">func fileExist(file string) bool {
  if _, err := os.Stat(file); err != nil {
    if os.IsNotExist(err) {
      return false
    }
  }
  return true
}
</code></pre>

<h6>exec</h6>

<pre><code class="go">cmd := exec.Command("sleep", "1")
err := cmd.Run()
</code></pre>

<h3>debug</h3>

<h5>time</h5>

<pre><code class="go">func debug() {
    fmt.Println("=&gt; ", time.Now().Sub(start))
}

start := time.Now()
</code></pre>

<h6>type class</h6>

<pre><code class="go  ">import "reflect"  
fmt.Println(reflect.TypeOf(doc))

import "github.com/go-ffmt/ffmt"
ffmt.P(m)  // type
ffmt.Puts  
ffmt.Pjson 
</code></pre>

<h6>ignore not used</h6>

<pre><code class="go">import (
    _ "fmt" //imported and not used
 )
</code></pre>

<h6>skip declared</h6>

<pre><code class="go">i := 1 
_ = i
</code></pre>

<h6>run time</h6>

<pre><code class="go">start := time.Now()
time.Now().Sub(start)
</code></pre>

<h5>screen</h5>

<pre><code class="go">import "github.com/inancgumus/screen"

func cleanScreen() {
    screen.Clear()
    screen.MoveTopLeft()
}
</code></pre>

<h3>time</h3>

<h6>time_format</h6>

<pre><code class="go">func timeFormat(t time.Time) string {
    return fmt.Sprintf("%d-%02d-%02d %02d:%02d:%02d", t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second())
}
today := time.Now()
timeFormat(today)
</code></pre>

<h6>sleep</h6>

<pre><code class="go">time.Sleep(1 * time.Second)

func sleep(t int) {
    time.Sleep(time.Duration(t) * time.Millisecond)
}
</code></pre>

<h6>unix</h6>

<pre><code class="go">func unixTime(y, m, d, h, m int) int {
    date := fmt.Sprintf("%v-%.2v-%.2vT%.2v:%.2v:00.000Z", y, m, d, h, m)
    t, _ := time.Parse(time.RFC3339, date)
    return int(t.Unix())
}
</code></pre>

<h5>date cal</h5>

<pre><code class="go">package main

import (
    "fmt"
    "time"
)

var _ = fmt.Println

var (
    y1, m1, d1 = 2019, 9, 2
    y2, m2, d2 = 2020, 7, 20
)

func main() {
    days := getTwoDate(y1, m1, d1, y2, m2, d2)
    fmt.Println(days)

    y3, m3, d3 := getAfterDays(y1, m1, d1, days)
    fmt.Println(y3, m3, d3)
}

func unixTime(y, m, d int) int {
    date := fmt.Sprintf("%v-%.2v-%.2vT00:00:00.000Z", y, m, d)
    t, _ := time.Parse(time.RFC3339, date)
    return int(t.Unix())
}

func getTwoDate(y1, m1, d1, y2, m2, d2 int) int {
    s := unixTime(y2, m2, d2) - unixTime(y1, m1, d1)
    return s / 86400
}

func getAfterDays(y, m, d, days int) (int, int, int) {
    unix := int64(unixTime(y, m, d) + days*60*60*24 - 60*60*8)
    t := time.Unix(unix, 0)
    return t.Year(), int(t.Month()), t.Day()
}
</code></pre>

<h3>string</h3>

<h6>strip</h6>

<p><code>strings.TrimSpace(str)</code></p>

<h6>string <-> to_int</h6>

<pre><code class="go">i, err := strconv.Atoi(s)
if err ! = nil {
    //
}
s := strconv.Itoa(i)
</code></pre>

<h6>sting <-> to_float</h6>

<pre><code class="go">fn, err := strconv.ParseFloat(cell, 64
</code></pre>

<h6>fill_zero</h6>

<pre><code class="go">func rjust(s string, n int, fill string) string {
    return strings.Repeat(fill, n-len(s)) + s
}
func ljust(s string, n int, fill string) string {
    return s + strings.Repeat(fill, n-len(s))
}
</code></pre>

<h6>regexp</h6>

<pre><code class="go">match, _ := regexp.MatchString(keyword, str)
r, _ := regexp.Compile(keyword)

//scan
re := regexp.MustCompile(keyword)
match := re.FindStringSubmatch(l)
if len(match) &gt; 0 {
    fmt.Println(match[1])
}
</code></pre>

<h6>chr <-> ord</h6>

<pre><code class="go">func ord(s string) int {
    return int([]byte(s)[0])
}
func chr(i int) string {
    return fmt.Sprintf("%c", rune(i))
}
</code></pre>

<h6>string reverse</h6>

<pre><code class="go">func strReverse(str string) string {
    comb := ""
    for i := len(str) - 1; i &gt;= 0; i-- {
        comb += string(str[i])
    }
    return comb
}
</code></pre>

<h6>index</h6>

<pre><code class="go">func strIndex(str string, bstr string) int {
    arr := strings.Split(str, "")
    for i, e := range arr {
        if bstr == string(e) {
            return i
        }
    }
    return -1
}
func strIndexS(str string, bstr string) []int {
    arr := strings.Split(str, "")
    is := []int{}
    for i, e := range arr {
        if bstr == string(e) {
            is = append(is, i)
        }
    }
    return is
}
</code></pre>

<h5>slice ch string</h5>

<pre><code class="go">func sliceChString(ch string, start int, end int) string {
    var size int
    var chs = []rune(ch)
    if len(chs) &gt; end &amp;&amp; end &gt; start {
        result := ""
        for _, e := range chs {
            str := string(e)
            if ord(str) &gt; 127 {
                size += 2
            } else {
                size += 1
            }
            result += str
            if size &gt; (end-start)*2 {
                break
            }
        }
        return result
    }
    return ch
}
</code></pre>

<h3>#</h3>

<pre><code class="go">func strEachSlice(str string, l int) []string {
    arr := strings.Split(str, "")
    var ar []string
    size := len(arr)
    for i := 0; i &lt; size; i = i + l {
        j := i + l
        if j &gt; size {
            j = size
        }
        ar = append(ar, strings.Join(arr[i:j], ""))
    }
    return ar
}
</code></pre>

<h3>array</h3>

<h6>eachSlice N part</h6>

<pre><code class="go">func eachSlice(arr []string, l int) [][]string {
    var ar [][]string
    size := len(arr)
    for i := 0; i &lt; size; i = i + l {
        j := i + l
        if j &gt; size {
            j = size
        }
        fmt.Println(len(arr[i:j]))
        ar = append(ar, arr[i:j])
    }
    return ar
}
</code></pre>

<h6>index</h6>

<pre><code class="go">func arrIncludeIndex(arr []string, str string) int {
    for i, e := range arr {
        if str == e {
            return i
        }
    }
    return -1
}
func arrIndexS(arr []string, str string) []int {
    is := []int{}
    for i, e := range arr {
        if str == e {
            is = append(is, i)
        }
    }
    return is
}

func arrRemoveByIndex(arr []string, idx int) []string {
    arr[idx] = arr[len(arr)-1]
    return arr[:len(arr)-1]
}
</code></pre>

<h6>bubbleSort</h6>

<pre><code class="go">func bubbleSort(arr []int) {
    size := len(arr)
    for i := 0; i &lt; size; i++ {
        for j := 1; j &lt; size; j++ {
            if arr[j] &gt; arr[j-1] {
                arr[j], arr[j-1] = arr[j-1], arr[j]
            }
        }
    }
}
</code></pre>

<h6>duplicate</h6>

<pre><code class="go">type Count struct {
    id    string
    count int
}

func bubbleSort(arr []Count) {
    size := len(arr)
    for i := 0; i &lt; size; i++ {
        for j := 1; j &lt; size; j++ {
            if arr[j].count &gt; arr[j-1].count {
                arr[j], arr[j-1] = arr[j-1], arr[j]
            }
        }
    }
}

func arrayDuplicate(arr []string) []Count {
    cs := make(map[string]int)
    for _, e := range arr {
        _, exist := cs[e]
        if exist {
            cs[e] += 1
        } else {
            cs[e] = 1
        }
    }
    count := []Count{}
    for cc := range cs {
        c := Count{cc, cs[cc]}
        count = append(count, c)
    }
    bubbleSort(count)
    return count
}
</code></pre>

<h6>sub</h6>

<pre><code class="go">func arrSub(arr1 []int, arr2 []int) []int {
    r := []int{}
    for _, e1 := range arr1 {
        if !arrInclude(arr2, e1) {
            r = append(r, e1)
        }
    }
    return r
}
</code></pre>

<h6>include</h6>

<pre><code class="go">func arrInclude(arr []int, str int) bool {
    for _, e := range arr {
        if str == e {
            return true
        }
    }
    return false
}
func arr1InclueArr2(arr1 []int, arr2 []int) bool {
    for _, e := range arr1 {
        if !reflect.DeepEqual(e, arr2) {
            return false
        }

    }
    return true
}
</code></pre>

<h5>Equal</h5>

<p><code>reflect.DeepEqual(a, b)</code></p>

<h5>compare</h5>

<pre><code class="go">func arrCompare(a1, a2 []string) ([]string, []string, []string) {
    var d1, same []string
    for _, e1 := range a1 {
        idx := arrIncludeIndex(a2, e1)
        if idx != -1 {
            same = append(same, e1)
            a2 = arrRemoveByIndex(a2, idx)
        } else {
            d1 = append(d1, e1)
        }
    }
    return d1, a2, same
}
</code></pre>

<h3>math</h3>

<h6>power</h6>

<pre><code class="go">import "math"
math.Pow(2, 5)

func pow(n, p int) int {
    if p == 1 {
        return n
    }
    return n * pow(n, p-1)
}
</code></pre>

<h6>bit</h6>

<pre><code class="go">n, err := strconv.ParseUint(val, 16, 32)
if err != nil {
    panic(err)
}
</code></pre>

<h6>d</h6>

<pre><code class="go">math.Ceil(0.2)
math.Floor(0.2)
</code></pre>

<h5>even odd</h5>

<pre><code class="go">func evenBool(i int) bool {
    return i%2 == 0
}
func oddBool(i int) bool {
    return i%2 != 0
}
</code></pre>

<h6>toHex</h6>

<pre><code class="go">func toHex(i int) string {
    return fmt.Sprintf("%x", i)
}
</code></pre>

<h6>rand</h6>

<pre><code class="go">"math/rand"

func randNumStr(min, max float64) string {
    rand.Seed(time.Now().UnixNano())
    n := min + rand.Float64()*(max-min)
    return fmt.Sprintf("%.1f", n)
}

func randNumInt(min, max int) int {
    rand.Seed(time.Now().UnixNano())
    return min + rand.Intn(max-min+1)
}
</code></pre>

<h3>image</h3>

<pre><code class="go">func rgbtoHex(i uint32) string {
    hex := fmt.Sprintf("%x", i)
    return hex[0:2]
}

func rgbaToPixel(r uint32, g uint32, b uint32, a uint32) string {
    return rgbtoHex(r) + rgbtoHex(g) + rgbtoHex(b)
}
img, _, err := image.Decode(file)

bounds := img.Bounds()
width, height := bounds.Max.X, bounds.Max.Y

pixel := rgbaToPixel(img.At(x, y).RGBA())
</code></pre>

<pre><code class="go">
  f, err = os.Open(input)
        img, _, err = image.Decode(f)
        if err != nil {
            fmt.Println(err)
            os.Exit(1)
        }
img = image.NewRGBA(image.Rect(0, 0, width, width))
</code></pre>

<h3>gin</h3>

<h5>soup</h5>

<pre><code class="go">import(
    "github.com/anaskhan96/soup"
)
func getResp(url string) string {
    req, e := http.NewRequest("GET", url, nil)
    if e != nil {
        os.Exit(11)
    }
    //cookie := http.Cookie{
    //    Name:  "over18",
    //    Value: "1",
    //}
    //req.AddCookie(&amp;cookie)
    res, e := http.DefaultClient.Do(req)
    if e != nil {
        os.Exit(12)
    }
    if res.StatusCode != http.StatusOK {
        os.Exit(13)
    }
    body, e := ioutil.ReadAll(res.Body)
    if e != nil {
        os.Exit(14)
    }
    return string(body)
}
func main (){
    resp := getResp(url)
    doc := soup.HTMLParse(resp)
}
</code></pre>

<h5>table</h5>

<pre><code class="go">data := [][]string
info := doc.Find("table", "class", "auto-style4")
table := info.FindAll("tr")
for _, tr := range table {
    var tmp []string
    for _, td := range tr.FindAll("td", "class", "auto-style5") {
        tmp = append(tmp, td)
    }
    data = append(data, tmp)
}
</code></pre>

<h5>br</h5>

<pre><code class="go">data := [][]string
for _, t := range td.Children() {
    if t.NodeValue != "br" {
        data = append(data, t.NodeValue)
    }
}
</code></pre>

<h5>nbsp</h5>

<pre><code class="go">func removeNbsp(s string) string {
    return strings.Replace(s, "\u00A0", "", -1)
}

func removeNbsp(s string) string {
    var txt string
    for _, b := range []byte(s) {
        if b != 194 &amp;&amp; b != 160 {
            txt += string(b)
        }
    }
    return txt
}
</code></pre>
]]></content>
  </entry>
  
 </feed>
