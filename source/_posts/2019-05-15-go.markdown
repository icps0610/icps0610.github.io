---
layout: post
title: "go"
date: 2019-05-15 15:34:10 +0800
comments: true
categories: golang
---

### cmd

###### toEXE  
``` 
windoes/linux amd64/386
GOOS=windows GOARCH=amd64 go build -o hello.exe hello.go
```
###### convert  
`https://mholt.github.io/curl-to-go/`  
`https://mholt.github.io/json-to-go/`
`https://github.com/Terry-Mao/paint`  
###### argv
`os.Args[1]`
##### run command
``` go
cmd := exec.Command("ipconfig")
_, err := cmd.CombinedOutput()
if err != nil {
    fmt.Println(err)
}


cmd := "ping -c 1 127.0.0.1 | grep icmp_seq"
out, err := exec.Command("bash", "-c", cmd).Output()
fmt.Println(string(out))
printError(err)
```
##### ipconfig
``` go
ifaces, _ := net.Interfaces()
// handle err
for _, i := range ifaces {
    addrs, _ := i.Addrs()
    // handle err
    for _, addr := range addrs {
        var ip net.IP
        switch v := addr.(type) {
        case *net.IPNet:
            ip = v.IP
        case *net.IPAddr:
            ip = v.IP
        }
        fmt.Println(ip)
    }
}
```
##### screenShot
``` go
"github.com/kbinani/screenshot"
"github.com/oliamb/cutter"
"image"
"image/png"

func getScreenshot(px, py, width, height int, imageName string) {
    bounds := screenshot.GetDisplayBounds(0)

    img, err := screenshot.CaptureRect(bounds)
    if err != nil {
        fmt.Println(err)
    }
    file, _ := os.Create(imageName)
    defer file.Close()

    croppedImg, err := cutter.Crop(img, cutter.Config{
        Anchor: image.Point{px, py},
        Width:  width,
        Height: height,
    })

    png.Encode(file, croppedImg)
    sleep(delay)
}
```
``` go
"github.com/oliamb/cutter"
"github.com/sclevine/agouti"
"image"
"image/png"
func getScreenshot(page *agouti.Page, px, py, width, height int, imageName string) {
    page.Screenshot(imageName)

    f, err := os.Open(imageName)
    if err != nil {
        fmt.Println("Cannot open file", err)
    }
    img, _, err := image.Decode(f)
    if err != nil {
        fmt.Println("Cannot decode image:", err)
    }
    file, _ := os.Create(imageName)
    defer file.Close()

    croppedImg, err := cutter.Crop(img, cutter.Config{
        Anchor: image.Point{px, py},
        Width:  width,
        Height: height,
    })

    png.Encode(file, croppedImg)
    sleep(delay)
}

```

###### curl
``` go
import (
    "io/ioutil"
)
resp, err := http.Get(url)
if err != nil {
    // handle err
}
defer resp.Body.Close()
body, e := ioutil.ReadAll(resp.Body)

if e != nil {
   // handle err
}
string(body)
```
###### input
``` go
reader := bufio.NewReader(os.Stdin)
fmt.Print("file: ")
ipt, _ := reader.ReadString('\n')
input := strings.TrimSuffix(ipt, "\n")
return input
```
##### continue
``` go
fmt.Print("Press 'Enter' to continue...")
bufio.NewReader(os.Stdin).ReadBytes('\n')
```
###### IO
``` go
data := []byte("hello\ngo\n")
err := ioutil.WriteFile("/tmp/data", data, 0644)


func writeLines(lines []string, path string) {
    file, err := os.Create(path)
    if err != nil {
        fmt.Println(err)
    }
    defer file.Close()
    for _, line := range lines {
        file.WriteString(line + "\n")
    }
}

import(
    "golang.org/x/text/encoding/traditionalchinese"
    "golang.org/x/text/transform"
)

func readfile(path string) []string {
    file, err := os.Open(path)
    if err != nil {
        fmt.Println(err)
    }
    defer file.Close()
    var lines []string
    line := bufio.NewScanner(file)
    for line.Scan() {
        //str, _, _ := transform.String(traditionalchinese.Big5.NewDecoder(), str2)
        //str2, _, _ := transform.String(traditionalchinese.Big5.NewEncoder(), str)
        lines = append(lines, line.Text())
    }
    return lines
}


//win utf-16 le to utf-8
import "github.com/malexdev/utfutil"
d, _ := utfutil.ReadFile("txt", utfutil.UTF8)
c := string(d)


func appendFile(path string, data []string) {
    f, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        log.Println(err)
    }
    defer f.Close()

    for _, line := range data {
        f.WriteString(line + "n")
    }

}
```
###### Json
``` go
imprt "encoding/json"
type Employee struct {
    Name string
    Age  int
}

type List struct {
    ID []*Employee
}

func writeJson(fname string, data []Employee) {
    file, _ := json.MarshalIndent(data, "", " ")
    _ = ioutil.WriteFile(fname, file, 0644)
}
func readJson(fname string) []Employee {
    file, _ := ioutil.ReadFile(fname)
    reaJson := []Employee{}
    _ = json.Unmarshal([]byte(file), &reaJson)
    return reaJson
}
fname := "user.json"
writeJson(fname, p)
reaJson := readJson(fname)
ffmt.Puts(reaJson[0].Name)
```
``` go
var c map[string][]map[string]interface{}
var cs []string
json.Unmarshal([]byte(str), &c)

t := c["content_elements"]

for _, e := range t {
    c := e["content"]
    if c != nil {
        cs = append(cs, fmt.Sprintf("%s", c))
    }
}
return cs
```

##### pwd
``` go
import(
    "os"
    "path/filepath"
)

dir, err := filepath.Abs(filepath.Dir(os.Args[0]))
dir, err := os.Getwd()
```
###### filepath
``` go
import "path/filepath"
dir, file := filepath.Split("/go/go.mod")

fmt.Println(dir)
fmt.Println(file)
```

###### fileExist
``` go
func fileExist(file string) bool {
  if _, err := os.Stat(file); err != nil {
    if os.IsNotExist(err) {
      return false
    }
  }
  return true
}
```
###### exec
``` go
cmd := exec.Command("sleep", "1")
err := cmd.Run()
```


### debug

##### time
``` go
func debug() {
    fmt.Println("=> ", time.Now().Sub(start))
}

start := time.Now()
```

###### type class
``` go  
import "reflect"  
fmt.Println(reflect.TypeOf(doc))

import "github.com/go-ffmt/ffmt"
ffmt.P(m)  // type
ffmt.Puts  
ffmt.Pjson 


```  
###### ignore not used
``` go
import (
    _ "fmt" //imported and not used
 )
```
###### skip declared
``` go
i := 1 
_ = i
```
###### run time
``` go
start := time.Now()
time.Now().Sub(start)
```
##### screen
``` go
import "github.com/inancgumus/screen"

func cleanScreen() {
    screen.Clear()
    screen.MoveTopLeft()
}
```

### time

###### time_format

``` go
func timeFormat() string {
    t := time.Now()
    return fmt.Sprintf("%d-%02d-%02d", t.Year(), int(t.Month()), t.Day())
}
```
###### sleep
``` go
time.Sleep(1 * time.Second)

func sleep(t int) {
    time.Sleep(time.Duration(t) * time.Millisecond)
}
```
###### unix
``` go
func unixTime(y, m, d, h, m int) int {
    date := fmt.Sprintf("%v-%.2v-%.2vT%.2v:%.2v:00.000Z", y, m, d, h, m)
    t, _ := time.Parse(time.RFC3339, date)
    return int(t.Unix())
}
```

##### date cal
``` go
package main

import (
    "fmt"
    "time"
)

var _ = fmt.Println

var (
    y1, m1, d1 = 2019, 9, 2
    y2, m2, d2 = 2020, 7, 20
)

func main() {
    days := getTwoDate(y1, m1, d1, y2, m2, d2)
    fmt.Println(days)

    y3, m3, d3 := getAfterDays(y1, m1, d1, days)
    fmt.Println(y3, m3, d3)
}

func unixTime(y, m, d int) int {
    date := fmt.Sprintf("%v-%.2v-%.2vT00:00:00.000Z", y, m, d)
    t, _ := time.Parse(time.RFC3339, date)
    return int(t.Unix())
}

func getTwoDate(y1, m1, d1, y2, m2, d2 int) int {
    s := unixTime(y2, m2, d2) - unixTime(y1, m1, d1)
    return s / 86400
}

func getAfterDays(y, m, d, days int) (int, int, int) {
    unix := int64(unixTime(y, m, d) + days*60*60*24 - 60*60*8)
    t := time.Unix(unix, 0)
    return t.Year(), int(t.Month()), t.Day()
}

```


### string

###### strip
`strings.TrimSpace(str)`
###### string <-> to_int
``` go
i, err := strconv.Atoi(s)
if err ! = nil {
    //
}
s := strconv.Itoa(i)
```
###### sting <-> to_float
``` go
fn, err := strconv.ParseFloat(cell, 64
```
###### fill_zero
``` go
func rjust(s string, n int, fill string) string {
    return strings.Repeat(fill, n-len(s)) + s
}
func ljust(s string, n int, fill string) string {
    return s + strings.Repeat(fill, n-len(s))
}
```
###### regexp
``` go
match, _ := regexp.MatchString(keyword, str)
r, _ := regexp.Compile(keyword)

//scan
re := regexp.MustCompile(keyword)
match := re.FindStringSubmatch(l)
if len(match) > 0 {
    fmt.Println(match[1])
}
```
###### chr <-> ord
``` go
func ord(s string) int {
    return int([]byte(s)[0])
}
func chr(i int) string {
    return fmt.Sprintf("%c", rune(i))
}
```
###### string reverse
``` go
func strReverse(str string) string {
    comb := ""
    for i := len(str) - 1; i >= 0; i-- {
        comb += string(str[i])
    }
    return comb
}
```
###### index
``` go
func strIndex(str string, bstr string) int {
    arr := strings.Split(str, "")
    for i, e := range arr {
        if bstr == string(e) {
            return i
        }
    }
    return -1
}
func strIndexS(str string, bstr string) []int {
    arr := strings.Split(str, "")
    is := []int{}
    for i, e := range arr {
        if bstr == string(e) {
            is = append(is, i)
        }
    }
    return is
}
```
##### slice ch string
``` go
func sliceChString(ch string, start int, end int) string {
    var size int
    var chs = []rune(ch)
    if len(chs) > end && end > start {
        result := ""
        for _, e := range chs {
            str := string(e)
            if ord(str) > 127 {
                size += 2
            } else {
                size += 1
            }
            result += str
            if size > (end-start)*2 {
                break
            }
        }
        return result
    }
    return ch
}
```
####
``` go
func strEachSlice(str string, l int) []string {
    arr := strings.Split(str, "")
    var ar []string
    size := len(arr)
    for i := 0; i < size; i = i + l {
        j := i + l
        if j > size {
            j = size
        }
        ar = append(ar, strings.Join(arr[i:j], ""))
    }
    return ar
}

```



### array
###### eachSlice N part
``` go
func eachSlice(arr []string, l int) [][]string {
    var ar [][]string
    size := len(arr)
    for i := 0; i < size; i = i + l {
        j := i + l
        if j > size {
            j = size
        }
        fmt.Println(len(arr[i:j]))
        ar = append(ar, arr[i:j])
    }
    return ar
}
```
###### index
``` go
func arrIncludeIndex(arr []string, str string) int {
    for i, e := range arr {
        if str == e {
            return i
        }
    }
    return -1
}
func arrIndexS(arr []string, str string) []int {
    is := []int{}
    for i, e := range arr {
        if str == e {
            is = append(is, i)
        }
    }
    return is
}

func arrRemoveByIndex(arr []string, idx int) []string {
    arr[idx] = arr[len(arr)-1]
    return arr[:len(arr)-1]
}
```
###### bubbleSort
``` go
func bubbleSort(arr []int) {
    size := len(arr)
    for i := 0; i < size; i++ {
        for j := 1; j < size; j++ {
            if arr[j] > arr[j-1] {
                arr[j], arr[j-1] = arr[j-1], arr[j]
            }
        }
    }
}
```
###### duplicate
``` go
type Count struct {
    id    string
    count int
}

func bubbleSort(arr []Count) {
    size := len(arr)
    for i := 0; i < size; i++ {
        for j := 1; j < size; j++ {
            if arr[j].count > arr[j-1].count {
                arr[j], arr[j-1] = arr[j-1], arr[j]
            }
        }
    }
}

func arrayDuplicate(arr []string) []Count {
    cs := make(map[string]int)
    for _, e := range arr {
        _, exist := cs[e]
        if exist {
            cs[e] += 1
        } else {
            cs[e] = 1
        }
    }
    count := []Count{}
    for cc := range cs {
        c := Count{cc, cs[cc]}
        count = append(count, c)
    }
    bubbleSort(count)
    return count
}

```
###### sub
``` go
func arrSub(arr1 []int, arr2 []int) []int {
    r := []int{}
    for _, e1 := range arr1 {
        if !arrInclude(arr2, e1) {
            r = append(r, e1)
        }
    }
    return r
}
```
###### include
``` go
func arrInclude(arr []int, str int) bool {
    for _, e := range arr {
        if str == e {
            return true
        }
    }
    return false
}
func arr1InclueArr2(arr1 []int, arr2 []int) bool {
    for _, e := range arr1 {
        if !reflect.DeepEqual(e, arr2) {
            return false
        }

    }
    return true
}
```
##### Equal
`reflect.DeepEqual(a, b)`

##### compare
``` go
func arrCompare(a1, a2 []string) ([]string, []string, []string) {
    var d1, same []string
    for _, e1 := range a1 {
        idx := arrIncludeIndex(a2, e1)
        if idx != -1 {
            same = append(same, e1)
            a2 = arrRemoveByIndex(a2, idx)
        } else {
            d1 = append(d1, e1)
        }
    }
    return d1, a2, same
}
```


### math
###### power
``` go
import "math"
math.Pow(2, 5)

func pow(n, p int) int {
    if p == 1 {
        return n
    }
    return n * pow(n, p-1)
}
```
###### bit
``` go
n, err := strconv.ParseUint(val, 16, 32)
if err != nil {
    panic(err)
}
```
######  d
``` go
math.Ceil(0.2)
math.Floor(0.2)
```
##### even odd
``` go
func evenBool(i int) bool {
    return i%2 == 0
}
func oddBool(i int) bool {
    return i%2 != 0
}
```
###### toHex
``` go
func toHex(i int) string {
    return fmt.Sprintf("%x", i)
}
```
###### rand
``` go
"math/rand"

func randNumStr(min, max float64) string {
    rand.Seed(time.Now().UnixNano())
    n := min + rand.Float64()*(max-min)
    return fmt.Sprintf("%.1f", n)
}

func randNumInt(min, max int) int {
    rand.Seed(time.Now().UnixNano())
    return min + rand.Intn(max-min+1)
}

```

### image
``` go
func rgbtoHex(i uint32) string {
    hex := fmt.Sprintf("%x", i)
    return hex[0:2]
}

func rgbaToPixel(r uint32, g uint32, b uint32, a uint32) string {
    return rgbtoHex(r) + rgbtoHex(g) + rgbtoHex(b)
}
img, _, err := image.Decode(file)

bounds := img.Bounds()
width, height := bounds.Max.X, bounds.Max.Y

pixel := rgbaToPixel(img.At(x, y).RGBA())

```
``` go

  f, err = os.Open(input)
        img, _, err = image.Decode(f)
        if err != nil {
            fmt.Println(err)
            os.Exit(1)
        }
img = image.NewRGBA(image.Rect(0, 0, width, width))

```
### gin

##### soup
``` go
import(
    "github.com/anaskhan96/soup"
)
func getResp(url string) string {
    req, e := http.NewRequest("GET", url, nil)
    if e != nil {
        os.Exit(11)
    }
    //cookie := http.Cookie{
    //    Name:  "over18",
    //    Value: "1",
    //}
    //req.AddCookie(&cookie)
    res, e := http.DefaultClient.Do(req)
    if e != nil {
        os.Exit(12)
    }
    if res.StatusCode != http.StatusOK {
        os.Exit(13)
    }
    body, e := ioutil.ReadAll(res.Body)
    if e != nil {
        os.Exit(14)
    }
    return string(body)
}
func main (){
    resp := getResp(url)
    doc := soup.HTMLParse(resp)
}
```

##### table
``` go
data := [][]string
info := doc.Find("table", "class", "auto-style4")
table := info.FindAll("tr")
for _, tr := range table {
    var tmp []string
    for _, td := range tr.FindAll("td", "class", "auto-style5") {
        tmp = append(tmp, td)
    }
    data = append(data, tmp)
}
```
##### br 
``` go
data := [][]string
for _, t := range td.Children() {
    if t.NodeValue != "br" {
        data = append(data, t.NodeValue)
    }
}
```

##### nbsp
``` go
func removeNbsp(s string) string {
    return strings.Replace(s, "\u00A0", "", -1)
}

func removeNbsp(s string) string {
    var txt string
    for _, b := range []byte(s) {
        if b != 194 && b != 160 {
            txt += string(b)
        }
    }
    return txt
}
```